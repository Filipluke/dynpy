import dynpy
from dynpy.utilities.report import ReportText
from .report import Markdown
from .documents.document import ODESystemOverviewReport
from github import Github
import getpass
from github import Auth
import pint
import inspect
from dynpy.utilities.documents import document
from dynpy.utilities.templates.document import Guide

issue_no = 567
title = 'implementation of overview report for `ODESystem` child classes'
guide_class = ODESystemOverviewReport

meet_issue_code_str = """The following actions are to do, in order to prepare the meeting and the guide:

- [{tic}] #{issue_no+1}

- [{tic}] #{issue_no+2}

- [{tic}] #{issue_no+3}

"""


meet_time_issue_code_str = """The goal is to schedule the meeting in Teams calendar on {date} at {time}.

"""

meet_arrange_issue_code_str ="""The goal is to arrange and execute the meeting for {title}. The following things should be prepared:

- [{tic}] scope and schedule of meeting (in one week);

- [{tic}] conducting team (in two weeks);

- [{tic}] guide or instructions with examples (one week before meeting);

- [{tic}] announcement (in Slack and Teams channel) with basic information (conducting persons, date,scope,schedule) (one week before meeting);

- [{tic}] exemplary code in Jupyter (link) (one week before meeting).

"""


meet_guide_issue_code_str ="""The goal is to prepare or improve a guide or report that is generated by the following code:

```python
from {guide_class_module} import {guide_class_name}
{guide_class_name}()
```

"""

class MeetingIssueCreator:
    _title = 'implementation of ODESystem overview report'
    _issue_no = 567
    _guide = ODESystemOverviewReport
    _time = '20:30'
    _date = '2024.07.27'
    
    def __init__(self,title=None,no=None,guide=None,date=None,time=None,done=False,*args,**kwargs):
        if title is not None: self._title = title
        if no is not None: self._issue_no = no
        if guide is not None: self._guide = guide
        if date is not None: self._date= date
        if time is not None: self._time = time
        self._done = done
        
    
    def _get_elems_dict(self):

        if self._done: tic = 'x'
        else: tic = ' '

        guide_class = self._guide

        elems_dict = {
                'title':self._title,
                'issue_no':self._issue_no,
                'issue_no+1':self._issue_no+1,
                'issue_no+2':self._issue_no+2,
                'issue_no+3':self._issue_no+3,
                'guide_class_module':guide_class.__module__,
                'guide_class_name':guide_class.__name__,
                'date':self._date,
                'time':self._time,
                'tic':tic
                }
        
        return elems_dict
    
    def get_issues_titles(self):
        
        
        # Issue no. #{issue_no}
        ## Preparation of meeting and guide for {title}

        issue_no = self._issue_no
        title = self._title

        titles_dict =   {
                        'meet':f'Preparation of meeting and guide for {title}',
                        'time':f'Scope and time scheduling of the meeting for {title} (issue #{issue_no} related)',
                        'arrange':f'Arrangement and execution of the meeting for {title} (issue #{issue_no} related)',
                        'guide':f'Preparation or improvement of the guide for {title} (issue #{issue_no} related)',
                        }
        
        return titles_dict
        
    def get_issue_str(self):
        elems_dict = self._get_elems_dict()
        issue_no = self._issue_no
        
        titles = self.get_issues_titles()
        
        meet_issue_dict = self.get_meet_issue_dict()
        time_issue_dict = self.get_time_issue_dict()
        arrange_issue_dict = self.get_arrange_issue_dict()
        guide_issue_dict = self.get_guide_issue_dict()
        
        
        issue_code_str = (f'# Issue no. #{issue_no} \n '+
                        '## '+meet_issue_dict['title'] + '\n ' +
                        meet_issue_dict['body'] + '\n ' +
                        f'# Issue no. #{issue_no+1} \n '+
                        '## '+ time_issue_dict['title'] + '\n ' +
                        time_issue_dict['body'] + '\n ' +
                        f'# Issue no. #{issue_no+2} \n '+
                        '## '+arrange_issue_dict['title'] + '\n ' +
                        arrange_issue_dict['body'] + '\n ' +
                        f'# Issue no. #{issue_no+3} \n ' +
                        '## '+guide_issue_dict['title'] + '\n ' +
                        guide_issue_dict['body'])
        
        return issue_code_str


    def get_meet_issue_dict(self):
        elems_dict = self._get_elems_dict()
        titles = self.get_issues_titles()
                
        return {'title':titles['meet'],'body':meet_issue_code_str.format(**elems_dict)}

    def get_time_issue_dict(self):
        elems_dict = self._get_elems_dict()
        titles = self.get_issues_titles()
                
        return {'title':titles['time'],'body':meet_time_issue_code_str.format(**elems_dict)}


    def get_arrange_issue_dict(self):
        elems_dict = self._get_elems_dict()
        titles = self.get_issues_titles()
                
        return {'title':titles['arrange'],'body':meet_arrange_issue_code_str.format(**elems_dict)}
    
    
    def get_guide_issue_dict(self):
        elems_dict = self._get_elems_dict()
        titles = self.get_issues_titles()
                
        return {'title':titles['guide'],'body':meet_guide_issue_code_str.format(**elems_dict)}

    
    def _repr_markdown_(self):
        return self.get_issue_str()

    def publish_on_github(self,repository):
        
        guide_label=repository.get_label('guidance')
        
        issue_meet=repository.create_issue(**self.get_meet_issue_dict(),labels=[guide_label]#,assignees=wykon
                                )
        issue_time=repository.create_issue(**self.get_time_issue_dict(),labels=[guide_label],assignee='bogumilchilinski')
        issue_arrange=repository.create_issue(**self.get_arrange_issue_dict(),labels=[guide_label]#,assignees=wykon
                                )
        issue_guide=repository.create_issue(**self.get_guide_issue_dict(),labels=[guide_label]#,assignees=wykon
                                )
        
        return issue_meet,issue_time,issue_arrange,issue_guide

class GitHubInterface():

    '''
    GitHubInterface is a class to use the Github API v3. With it, you can manage your Github resources (repositories, user profiles, organizations, etc.) from Python scripts. It is based on Github class from PyGithub library and it mimics its methods.

    Examples:

    from dynpy.utilities.creators import GitHubInterface

    # Authentication is defined via github.Auth
    # using an access token to Public Web Github

    client = GitHubInterface()

    repos = client.get_issues_list(repo_name="bogumilchilinski/dynpy", state='open', assignee='amvdek')

    '''

    def __init__(self):

        pass_code = getpass.getpass('Github token')
        auth = Auth.Token(pass_code)
        g = Github(auth=auth)
        self.g = g

    def open(self):
        '''
        This method opens the connection with GitHub API by entering the token.

        Example:

        client = GitHubInterface()

        client.close()

        client.open()

        '''
        if self.g is None:
            pass_code = getpass.getpass('Github token')
            auth = Auth.Token(pass_code)
            g = Github(auth=auth)
            self.g = g
        else:
            pass

    def get_repos_list(self, string=False):
        '''
        This method returns the list of the repositories in form of Repository classes or in string type depending on boolean value of string argument.

        Example:

        client = GitHubInterface()

        client.get_repos_list(string=True)

        '''

        if string == False:
            return list(self.g.get_user().get_repos())
        else:
            repo_list=[]
            for repo in list(self.g.get_user().get_repos()):
                repo_list.append(repo.full_name)
            return repo_list

    def get_repo(self, full_name='bogumilchilinski/dynpy'):
        '''
        This method returns the Repository class from GitHub.

        Example:

        client = GitHubInterface()

        client.get_repo(full_name='bogumilchilinski/dynpy')

        '''

        return self.g.get_repo(full_name)

    def get_issues_list(self, repo_name='none', state='all', assignee='none', sort='none', since='none'):#, milestone='none',  labels='none', sort='none', direction='none', creator='none'):

        '''
        This method returns the list of the issues from GitHub Repository in form of Issue classes.

        Example:

        client = GitHubInterface()

        client.get_issues_list(repo_name='bogumilchilinski/dynpy', state='all', assignee='amvdek')
        client.get_issues_list(repo_name='bogumilchilinski/dynpy', state='open', assignee='amvdek')
        client.get_issues_list(repo_name='bogumilchilinski/dynpy', state='closed', assignee='amvdek')

        '''
        issue_list=[]
        for issue in list(self.g.get_repo(repo_name).get_issues(state=state, assignee=assignee, sort=sort, since=since)):#, milestone=milestone,  labels=labels, sort=sort, direction=direction, creator=creator)):
            issue_list.append(issue)
        return issue_list

    
    def as_df(self):
        '''
        This method returns the Pandas DataFrame containing Issues.

        Example:

        client = GitHubInterface()

        client.as_df()

        '''

        import pandas as pd

        issue_title_list=[]
        issue_number_list=[]
        issue_assignees_list=[]
        for issue in self.get_issues_list(repo_name='bogumilchilinski/dynpy', state='open', assignee='amvdek'):
            issue_title_list.append(issue.title)
            issue_number_list.append(issue.number)
#             issue_assignees_list.append(issue.assignees)

        data_dict = {'Issue title':issue_title_list, 'Issue number':issue_number_list, }#'Assignees':issue_assignees_list}

        return pd.DataFrame(data_dict)



    def open_issues(self, state='open', since=None, sort=None):
        '''
        This method returns the list of the Issues.

        Example:

        client = GitHubInterface()

        client.open_issues(state='open', since=None, sort=None)

        '''
        if self.g is not None:
            dp_repo=list(self.g.get_user().get_repos())[1]
            (dp_repo).full_name

            repo = self.g.get_repo(dp_repo.full_name)
            open_issues = repo.get_issues(state=state, since=since, sort=sort)
            for issue in open_issues:
                if 'class that creates a part of a report' in issue.title:
                    print(issue.title.split('`')[1])

            [issue.title.split('`')[1] for issue in open_issues if 'class that creates a part of a report' in issue.title ]

        else:
            return 'Reopen the client'


    def close(self):
        '''
        This method closes the connection with GitHub API.

        Example:

        client = GitHubInterface()

        client.close()

        '''
        if self.g is not None:
            g = self.g
            self.g = g.close()
        else:
            pass


class ClassLister:
    
    '''
    This is temporary solution, working on better one.
    
    Example of call code:
    
    ###############################
    import dynpy
    from dynpy.utilities.report import ReportText

    dir_str = 'dynpy.utilities.components.guides'

    ClassLister(dir_str).printer()
    ###############################
    '''
    
    import dynpy
    from datetime import date, time

    
    def __init__(self, directory):
        self.directory = directory
        
        import_str = f'from {directory} import *'
        exec(import_str) #exec i eval to dwie funkcje pozwalające na wykonanie komendy podanej jako string
    
    def submodgetter(self): 
        '''
        metoda zbiera liste sbmodułów z wskazanej scieżki
        
        '''
        import os.path, pkgutil
        
        pkgpath_str = f"os.path.dirname({self.directory}.__file__)"
        
        pkgpath = eval(pkgpath_str)
        list_of_sub_modules = [name for _, name, _ in pkgutil.iter_modules([pkgpath])]

        return list_of_sub_modules
    
    def classlistgetter(self, submod):
        
        '''
        metoda zbiera liste klass w podanym submodule
        
        init: submod
        '''
        
        import inspect

        import_str = f"from {self.directory}.{submod} import *"
        command_str = f"inspect.getmembers({self.directory}.{submod}, predicate=inspect.isclass)" #ta komenda zbiera liste wszystkich klas istniejących w danym submodule, niestety sa tu też klasy nas nie interesujące np. importy klas z numpy czy pandasa etc, dlatego dalej ta lista jest filtrowana
        
        import_eval = exec(import_str)
        members = eval(command_str)

        tmp_list = []

        for i in range(len(members)):
            if "__class__" in members[i][0]: #ten warunek doda klase do listy w przypadku gdy submoduł ma ta samą nazwe co klasa sama w sobie 
                tmp_list.append(submod)
            elif f'{self.directory}.{submod}' in str(members[i][1]):
                tmp_list.append(members[i][0])

        return tmp_list
    
    def printer(self):
        lst = []
        lst = self.submodgetter()
        
        cnt = 0
        
        for submod in lst:    
            class_lst = self.classlistgetter(submod)
            size = len(class_lst)
            
            if size != 0:
                display(ReportText(f'# {submod}'))

            for cl in class_lst:
                    display(ReportText(f'* {cl}'))
                    cnt += 1
        display(ReportText(f'Total class count is:{cnt}'))
    
    
    def initupdater(self):
        intro_str = f'''"""
This module provides the examples of mechanical models being practically used in calculations

Last update was done on {date.today()}

"""

import importlib

'''

        from datetime import date, time
        
        f = open('./output/test.py', 'w')
        f.write(intro_str)
        
        lst = []
        lst = self.submodgetter()
        for submod in lst:    
            class_lst = self.classlistgetter(submod)
            f.write(f'from .{submod} import ')

            size = len(class_lst)
            i = 1

            for cl in class_lst:

                if i < size:
                    f.write(f'{cl}, ')
                else:
                    f.write(f'{cl}')

                i += 1 

            f.write('\n\n')

        f.close()
#karolina - na szybko zrobilam to:
    def lister(self):
        lst = []
        lst = self.submodgetter()
        all_classes = []
        
        cnt = 0
        
        for submod in lst:
            class_lst = self.classlistgetter(submod)
            size = len(class_lst)
            if size != 0:
                all_classes.extend(class_lst)
        return all_classes


def list_of_guides_prime():
    md_str='Lista poradników: \n\n'
    for name, obj in inspect.getmembers(document):
        if inspect.isclass(obj) and 'Guide' in name:
                if obj is not Guide:
                    md_str=md_str+f'\t\t - {name} \n\n'
    return md_str



class ModuleStructure:
    
    '''
Class was created to support development work on dynsys.

Example usage:
===========================================================================================
import dynpy
from dynpy.utilities.report import ReportText

example = ModuleStructure(dynpy.utilities.components)
example.lister('Code') #Creates a list of components. Optional keyword used for filtering
example.printer() #Prints list in user friendly format
example.tree() #Prints created list in tree format
===========================================================================================
    '''
    
    def __init__(self, directory):
        
        import dynpy
        from datetime import date, time
        import inspect, os, types
        from dynpy.utilities.report import ReportText
        
        self.full_list = []

        if isinstance(directory, types.ModuleType):
            s = str(directory)
            self.directory = s[s.find("module '")+len("module '"):s.rfind("' from ")]
        elif isinstance(directory, str):
            self.directory = directory
        
        import_str = f'from {self.directory} import *'
        exec(import_str)

    def submodgetter(self):
        '''
Method collects a list of submodules in the given module
        
init: None
        '''
        import inspect
        import dynpy
        
        tmp_list = eval(f"inspect.getmembers({self.directory}, predicate=inspect.ismodule)")
        
        self.mod_list = []
        
        for i in range(len(tmp_list)):
            s = str(tmp_list[i][1])

            tmp = s[s.find("module '")+len("module '"):s.rfind("' from ")]
            
            if "dynpy" in tmp:
                self.mod_list.append(f'{tmp}')
                
        tmp_list.clear()
        
        for element in self.mod_list:
            exec(f'from {element} import *')
            tmp_list = eval(f"inspect.getmembers({element}, predicate=inspect.ismodule)")
            if tmp_list is not None:
                for i in range(len(tmp_list)):
                    s = str(tmp_list[i][1])
                    tmp = s[s.find("module '")+len("module '"):s.rfind("' from ")]
                    if ("dynpy" in tmp) and (tmp not in self.mod_list):
                        self.mod_list.append(f'{tmp}')
        
        self.mod_list = sorted(self.mod_list)
        
        return self.mod_list

    def _classlistgetter(self, submod, keyword):
        '''
Method collects a list of classes in the given submodule
keyword - optional argument, keyword by which the classes are searched for
        
init: submod,keyword
        '''
        
        import inspect

        import_str = f"from {submod} import *"
        command_str = f"inspect.getmembers({submod}, predicate=inspect.isclass)" 
        
        import_eval = exec(import_str)
        members = eval(command_str)

        tmp_list = []

        for i in range(len(members)):
            if "__class__" in members[i][0]: 
                if (keyword != None) and (keyword in members[i][0]):
                    tmp_list.append(submod)
                elif keyword == None:
                    tmp_list.append(submod)
            elif f'{submod}' in str(members[i][1]):
                if (keyword != None) and (keyword in members[i][0]):
                    tmp_list.append(members[i][0])
                elif keyword == None:
                    tmp_list.append(members[i][0])

        return tmp_list
    
    def lister(self, keyword = None):
        
        '''
Method collects a list of classes and parent submodule directory in the given module
keyword - optional argument, keyword by which the classes are searched for
        
init: keyword
        '''
        
        self.submodgetter()
        
        self.full_list = []
        
        cnt = 0
        
        for submod in self.mod_list:    
            class_lst = self._classlistgetter(submod, keyword)
            size = len(class_lst)
            
            if size != 0:
                for cl in class_lst:
                        self.full_list.append((submod, cl))
                        
                        cnt += 1
        
        return self.full_list
    
    def printer(self, keyword = None):
        
        '''
Method prints a list of classes and parent submodule directory in the given module
keyword - optional argument, keyword by which the classes are searched for
        
init: keyword
        '''
        
        if not self.full_list:
            self.lister(keyword)
        
        i = 0
        a = 0
        
        submod_prev = None
        class_name = self.full_list[0][1]
        
        for element in self.full_list:
            if submod_prev == self.full_list[i][0]:
                display(ReportText(f'* {self.full_list[i][1]}'))
                submod_prev = self.full_list[i][0]
            else:
                display(ReportText(f'### {self.full_list[i][0]}'))
                display(ReportText(f'* {self.full_list[i][1]}'))
                
                submod_prev = self.full_list[i][0]

            i = i+1 
        
        display(ReportText(f'Total class count is: {i}'))
        
    def tree(self, keyword = None):
        
        '''
Method prints a tree of classes
keyword - optional argument, keyword by which the classes are searched for
        
init: keyword
        '''
        
        if not self.full_list:
            self.lister(keyword)
        
        lst_comp = []
        i = 0

        while i != len(self.full_list):
            t_str = f'{self.full_list[i][0]}.{self.full_list[i][1]}'
            lst_comp.append(t_str)
            i=i+1
            
        root = TreeNode("dynpy")

        for element in lst_comp:
            root.find_and_insert(root, element.split(".")[1:])
        root.print()

class TreeNode:
    '''
Supporting class for ModuleStructure class    
    '''
    def __init__(self, name, parent = None):
        self.parent = parent
        self.name = name
        self.children = []

    def add_child(self, node):
        self.children.append(node)
        return node

    def print(self, is_root = True):
        pre_0 = "    "
        pre_1 = "│   "
        pre_2 = "├── "
        pre_3 = "└── "

        tree = self
        prefix = pre_2 if tree.parent and id(tree) != id(tree.parent.children[-1]) else pre_3

        while tree.parent and tree.parent.parent:
            if tree.parent.parent and id(tree.parent) != id(tree.parent.parent.children[-1]):
                prefix = pre_1 + prefix
            else:
                prefix = pre_0 + prefix

            tree = tree.parent

        if is_root:
            print(self.name)
        else:
            print(prefix + self.name)

        for child in self.children:
            child.print(False)
    
    @staticmethod
    def find_and_insert(parent, edges):
        if not edges:
            return

        match = [tree for tree in parent.children if tree.name == edges[0]]

        tree = match[0] if match else parent.add_child(TreeNode(edges[0], parent))

        __class__.find_and_insert(tree, edges[1:])        
        
        
def list_of_guides():

    dir_str = 'dynpy.utilities.documents'

    return ModuleStructure(dir_str).lister()

def list_of_components():

    dir_str = 'dynpy.utilities.components'
    
    return ModuleStructure(dir_str).lister()
def list_of_systems():

    dir_str = 'dynpy.models.mechanics'

    return ModuleStructure(dir_str).lister()